1) описание DFS в общем:
G = (V, e)
рекурсивный подход:
- берем стартовую вершину s  за корень дерева/графа
- добавляем вершину s в посещенные (visited[s])
- обозначим множество всех достижимых вершин из s как W = V\{s}
- для всех соседей вершины s (то есть соединенных с ней ребром e = (s, w), w из W):
    ~ если w нет в посещенных, вызвать DFS(G, w)

нерекурсивный(итеративный) подход:
DFS(G, s):
- заводим стэк STACK, visited - посещенные вершины (список, массив)
- кладем s в STACK
- пока стэк не пуст:
    ~ s = STACK.pop()
    ~ если s не в visited:
        - пометим s как посещенную
        - для всех соседей s положим их (соседей) в STACK

Подходы отличаются порядком обхода вершин. Путь до целевой вершины получаем реверсом посещенных
В отличие от BFS, DFS идет по ветке дерева до тех пор, пока есть следующая вершина. Если ее нет, возвращается к
предыдущей (у которой есть непосещенные соседи) и идет по непосещенной ветке.

2) моя имплементация DFS:
Подготовка:
- определим класс Square для описания вершин в графе:
    - инициализируем квадрат (поле шахматной доски)
    - переопределим метод сравнения и сложения (__eq__ и __add__ соответственно), чтобы сравнивать их легче
    - переопределим строковое представление инстансов класса
- EnumeratedLetters: name = буква, value = соответствующая цифра
- распарсим in.txt и создадим из указанных данных квадраты-клетки поля
- заведем список возможных ходов коня в соответствии с наложенными в задаче ограничениями по приоритету ходов
- DFS:
    - заводим стэк
    - кладем в посещенные клетки, в которых коня может бить пешка, и стартовую позицию коня
    - кладем в стэк стартовую вершину (позиция коня)
    - пока последняя положенная в стэк вершина не равна целевой вершине в графе:
        - назначим верхнюю (последнюю положенную в стэк) вершину текущей
        - для всех вершин из разрешенных списком:
            - следующей вершиной назначим текущую, сложенную с разрешенной
            - если следующая вершина существует и не содержится в списке посещенных, добавим ее туда и в стэк
            (таким образом мы соблюдаем приоритет поиска, то есть берем существующую и самую приоритетную)
- для вершин из стэка конкатенируем их в строку, разворачиваем и записываем в файл

